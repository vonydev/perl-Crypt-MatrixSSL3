diff -ENwbur -x '\.git' orig/matrixssl/core/coreConfig.h matrixssl/core/coreConfig.h
--- orig/matrixssl/core/coreConfig.h	1970-01-01 02:00:00.000000000 +0200
+++ matrixssl/core/coreConfig.h	2017-12-15 08:06:04.522304600 +0200
@@ -0,0 +1,96 @@
+/**
+ *      @file    coreConfig.h
+ *      @version $Format:%h%d$
+ *
+ *      Configuration settings for Matrix core module.
+ */
+/*
+ *      Copyright (c) 2013-2017 INSIDE Secure Corporation
+ *      Copyright (c) PeerSec Networks, 2002-2011
+ *      All Rights Reserved
+ *
+ *      The latest version of this code is available at http://www.matrixssl.org
+ *
+ *      This software is open source; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This General Public License does NOT permit incorporating this software
+ *      into proprietary programs.  If you are unable to comply with the GPL, a
+ *      commercial license for this software may be purchased from INSIDE at
+ *      http://www.insidesecure.com/
+ *
+ *      This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *      See the GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *      http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+#ifndef _h_PS_CORECONFIG
+# define _h_PS_CORECONFIG
+
+
+/******************************************************************************/
+/* Configurable features */
+/******************************************************************************/
+/**
+    Enable various levels of trace.
+    When these option is turned off, messages are silently
+    discarded and their text does not take space in the binary image.
+ */
+/* #define USE_CORE_TRACE */
+#  ifndef NO_CORE_ERROR
+#   define USE_CORE_ERROR
+#  endif
+#  ifndef NO_CORE_ASSERT
+#   define USE_CORE_ASSERT
+#  endif
+
+/**
+    When logging or tracing use psLog.h APIs.
+
+    Generally, using psLog.h allows more control over logging, because
+    it is possible to filter log and tracing information more efficiently.
+    However, this feature comes with a footprint cost, so the feature can be
+    disabled by setting NO_PS_LOGF_COMMON or by commenting out USE_PS_LOGF_COMMON
+    below.
+ */
+#ifdef NO_PS_LOGF_COMMON
+#define USE_PS_LOGF_COMMON
+#endif /* NO_PS_LOGF_COMMON */
+
+/**
+    If enabled, calls to the psError set of APIs will perform a platform
+    abort on the exeutable to aid in debugging.
+ */
+#  ifdef DEBUG
+/* #define HALT_ON_PS_ERROR  *//* NOT RECOMMENDED FOR PRODUCTION BUILDS */
+#  endif
+
+/**
+    Include the psCoreOsdepMutex family of APIs
+
+    @note If intending to compile crypto-cl, then this flag should
+    always be set.
+*/
+#  ifndef NO_MULTITHREADING
+#   define USE_MULTITHREADING
+#  endif /* NO_MULTITHREADING */
+
+/**
+    Include the psNetwork family of APIs
+
+    These APIs allow simple high-level socket api.
+ */
+#  define USE_PS_NETWORKING
+
+#endif   /* _h_PS_CORECONFIG */
+
+/******************************************************************************/
+
diff -ENwbur -x '\.git' orig/matrixssl/core/corelib.c matrixssl/core/corelib.c
--- orig/matrixssl/core/corelib.c	2017-12-15 08:06:04.537904600 +0200
+++ matrixssl/core/corelib.c	2017-12-15 11:45:28.311565900 +0200
@@ -1087,4 +1087,16 @@
 }
 
 /******************************************************************************/
+/*
+    Support for memory allocation in order to avoid applications that redefine
+    malloc/free (see Perl)
+*/
+void *psMallocNative(size_t size)
+{
+    return malloc(size);
+}
 
+void psFreeNative(void *ptr)
+{
+    free(ptr);
+}
diff -ENwbur -x '\.git' orig/matrixssl/core/osdep-types.h matrixssl/core/osdep-types.h
--- orig/matrixssl/core/osdep-types.h	2017-12-15 08:06:04.537904600 +0200
+++ matrixssl/core/osdep-types.h	2017-12-15 15:31:56.143745400 +0200
@@ -45,12 +45,18 @@
 #  define POSIX
 #  define LINUX
 #  define MATRIX_USE_FILE_SYSTEM
+#  include <sys/types.h>
 # elif defined(__APPLE__) && defined(__MACH__) /* Mac OS X */
 #  define POSIX
 #  define OSX
 #  define HAVE_NATIVE_INT64
 #  define MATRIX_USE_FILE_SYSTEM
 # elif defined(_WIN32) /* Windows */
+#  define __attribute__(x)
+#  define __func__ __FUNCTION__
+#  if !defined(va_copy)
+#    define va_copy(dest, src) ((dest) = (src))
+#  endif
 #  ifndef WIN32
 #   define WIN32
 #  endif
@@ -89,7 +95,7 @@
 # endif /* GNUC/CLANG */
 
 /* Try to determine if the compiler/platform supports 64 bit integer ops */
-# if !defined(HAVE_NATIVE_INT64) && defined(__SIZEOF_LONG_LONG__)
+# if !defined(HAVE_NATIVE_INT64) && (defined(__SIZEOF_LONG_LONG__) || defined(__GLIBC_HAVE_LONG_LONG))
 #  define HAVE_NATIVE_INT64 /* Supported by compiler */
 # endif
 
diff -ENwbur -x '\.git' orig/matrixssl/core/POSIX/psLog.c matrixssl/core/POSIX/psLog.c
--- orig/matrixssl/core/POSIX/psLog.c	2017-12-15 08:06:04.522304600 +0200
+++ matrixssl/core/POSIX/psLog.c	2017-12-15 13:58:42.366799700 +0200
@@ -611,6 +611,7 @@
 
     if (strlen(module_or_level) <= PS_LOGF_UNIT_MAX_LEN)
     {
+#ifndef WIN32
         /* use unsetenv/setenv to specify logging settings. */
         snprintf(buf, sizeof(buf), "PS_DISABLE_%.*s", (int)PS_LOGF_UNIT_MAX_LEN,
                  module_or_level);
@@ -618,6 +619,7 @@
         snprintf(buf, sizeof(buf), "PS_ENABLE_%.*s", (int)PS_LOGF_UNIT_MAX_LEN,
                  module_or_level);
         setenv(buf, "1", 0);
+#endif
     }
     psLogfFlush();
 }
@@ -629,6 +631,7 @@
 
     if (strlen(module_or_level) <= PS_LOGF_UNIT_MAX_LEN)
     {
+#ifndef WIN32
         /* use unsetenv/setenv to specify logging settings. */
         snprintf(buf, sizeof(buf), "PS_ENABLE_%.*s", (int)PS_LOGF_UNIT_MAX_LEN,
                  module_or_level);
@@ -636,6 +639,7 @@
         snprintf(buf, sizeof(buf), "PS_DISABLE_%.*s", (int)PS_LOGF_UNIT_MAX_LEN,
                  module_or_level);
         setenv(buf, "1", 0);
+#endif
     }
     psLogfFlush();
 }
diff -ENwbur -x '\.git' orig/matrixssl/core/psmalloc.h matrixssl/core/psmalloc.h
--- orig/matrixssl/core/psmalloc.h	2017-12-15 08:06:04.537904600 +0200
+++ matrixssl/core/psmalloc.h	2017-12-15 11:45:44.542494200 +0200
@@ -70,6 +70,14 @@
 #   define psFree(A, B)        free(A)
 #   define psFreeNoPool        free
 
+/*
+    Support for memory allocation in order to avoid applications that redefine
+    malloc/free (see Perl)
+*/
+
+void *psMallocNative(size_t size);
+void psFreeNative(void *ptr);
+
 #ifndef PS_POOL_T_DEFINED
 #define PS_POOL_T_DEFINED
 typedef int32 psPool_t;
diff -ENwbur -x '\.git' orig/matrixssl/crypto/aead/chacha20poly1305ietf/ref/chacha20_ref.c matrixssl/crypto/aead/chacha20poly1305ietf/ref/chacha20_ref.c
--- orig/matrixssl/crypto/aead/chacha20poly1305ietf/ref/chacha20_ref.c	2017-12-15 08:06:04.553504700 +0200
+++ matrixssl/crypto/aead/chacha20poly1305ietf/ref/chacha20_ref.c	2017-12-15 13:26:01.533646400 +0200
@@ -5,7 +5,7 @@
  Public domain.
  */
 
-#include "ps_chacha20poly1305ietf_config.h"
+#include "../ps_chacha20poly1305ietf_config.h"
 #ifdef USE_MATRIX_CHACHA20_POLY1305_IETF
 # include <stdint.h>
 # include <stdlib.h>
diff -ENwbur -x '\.git' orig/matrixssl/crypto/cryptoConfig.h matrixssl/crypto/cryptoConfig.h
--- orig/matrixssl/crypto/cryptoConfig.h	1970-01-01 02:00:00.000000000 +0200
+++ matrixssl/crypto/cryptoConfig.h	2017-12-15 08:06:04.522304600 +0200
@@ -0,0 +1,265 @@
+/**
+ *      @file    cryptoConfig.h
+ *      @version $Format:%h%d$
+ *
+ *      Configuration file for crypto features.
+ */
+/*
+ *      Copyright (c) 2013-2017 INSIDE Secure Corporation
+ *      Copyright (c) PeerSec Networks, 2002-2011
+ *      All Rights Reserved
+ *
+ *      The latest version of this code is available at http://www.matrixssl.org
+ *
+ *      This software is open source; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This General Public License does NOT permit incorporating this software
+ *      into proprietary programs.  If you are unable to comply with the GPL, a
+ *      commercial license for this software may be purchased from INSIDE at
+ *      http://www.insidesecure.com/
+ *
+ *      This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *      See the GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *      http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+#ifndef _h_PS_CRYPTOCONFIG
+# define _h_PS_CRYPTOCONFIG
+
+/******************************************************************************/
+/* Configurable features */
+/******************************************************************************/
+/**
+    Define to enable psTrace*Crypto APIs for debugging the crypto module.
+ */
+/* #define USE_CRYPTO_TRACE */
+
+#  ifdef DEBUG
+/* #define CRYPTO_ASSERT	 *//**< Extra sanity asserts */
+#  endif
+
+/******************************************************************************/
+/*
+    Use built-in cryptographic library delivered with MatrixSSL
+ */
+#   define USE_NATIVE_RSA /* Default built-in software support */
+
+/******************************************************************************/
+/**
+    Security related settings.
+
+    @security MIN_*_BITS is the minimum supported key sizes in bits, weaker
+    keys will be rejected.
+ */
+#  define MIN_ECC_BITS 192/**< @security Affects ECC curves below */
+
+#   define MIN_RSA_BITS    1024
+
+#    define MIN_DH_BITS 1024
+
+#  define USE_BURN_STACK/**< @security Zero sensitive data from the stack. */
+
+/******************************************************************************/
+/**
+    Public-Key Algorithm Support.
+ */
+#  define USE_RSA
+#  define USE_ECC
+#  define USE_DH
+/**< @note Enable verification of DSA signatures in certificate validation.
+   Works only when using the CL/SL library. @pre USE_CERT_PARSE. */
+/* #define USE_DSA_VERIFY */
+
+/******************************************************************************/
+/**
+    Build the PKCS and ASN1 extra CL sublibraries.
+    These are needed by the CL_PKCS API.
+ */
+
+/******************************************************************************/
+
+/**
+    Define to enable the individual NIST Prime curves.
+    @see http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf
+ */
+#  ifdef USE_ECC
+#    define USE_SECP192R1/**< @security FIPS allowed for sig ver only. */
+#   define USE_SECP224R1
+#   define USE_SECP256R1/**< @security NIST_SHALL */
+#   define USE_SECP384R1/**< @security NIST_SHALL */
+#   define USE_SECP521R1
+#  endif
+
+/**
+    Define to enable the individual Brainpool curves.
+    @see https://tools.ietf.org/html/rfc5639
+    @security WARNING: Public points on Brainpool curves are not validated
+ */
+#  ifdef USE_ECC
+/* #define USE_BRAIN224R1 */
+/* #define USE_BRAIN256R1 */
+/* #define USE_BRAIN384R1 */
+/* #define USE_BRAIN512R1 */
+#  endif
+
+/******************************************************************************/
+/**
+    Symmetric and AEAD ciphers.
+    @security Deprecated ciphers must be enabled in cryptolib.h
+ */
+/* #define USE_AES  *//* Enable/Disable AES */
+#  define USE_AES_CBC
+#  define USE_AES_GCM
+
+/** If you want new ciphersuites specified in RFC 7539 enable this.
+    Currently CHACHA20-based cipher suites are only supported by the newest
+    TLS clients and servers. These cipher suites are not allowed in FIPS
+    mode of operation.
+*/
+/* #define USE_CHACHA20_POLY1305_IETF */
+
+/** @security 3DES is still relatively secure, however is deprecated for TLS */
+#  define USE_3DES
+
+/******************************************************************************/
+/**
+    Digest algorithms.
+
+    @note SHA256 and above are used with TLS 1.2, and also used for
+    certificate signatures on some certificates regardless of TLS version.
+
+    @security MD5 is deprecated, but still required in combination with SHA-1
+    for TLS handshakes before TLS 1.2, meaning that the strength is at least
+    that of SHA-1 in this usage. The define USE_MD5SHA1 can be used to enable
+    MD5 only for this purpose. The only other usage of MD5 by TLS is for
+    certificate signatures and MD5 based cipher suites. Both of which are
+    disabled at compile time by default.
+
+    @security SHA1 will be deprecated in the future, but is still required in
+    combination with MD5 for versions prior to TLS 1.2. In addition, SHA1
+    certificates are still commonly used, so SHA1 support may be needed
+    to validate older certificates. It is possible to completely disable
+    SHA1 using TLS 1.2 and SHA2 based ciphersuites, and interacting
+    only with newer certificates.
+ */
+/* #define USE_SHA224	 *//**< @note Used only for cert signature */
+#  define USE_SHA256/**< @note Required for TLS 1.2 and above */
+#  define USE_HMAC_SHA256
+#  define USE_SHA384/**< @pre USE_SHA512 */
+#  define USE_HMAC_SHA384
+#  define USE_SHA512
+
+/**
+    @security SHA-1 based hashes are deprecated but enabled by default
+    @note ENABLE_SHA1_SIGNED_CERTS can additionally be configured below.
+ */
+#  define USE_SHA1
+#  define USE_HMAC_SHA1
+
+/**
+    @security MD5 is considered insecure, but required by TLS < 1.2
+    @note ENABLE_MD5_SIGNED_CERTS can additionally be configured below.
+ */
+#  define USE_MD5
+#  define USE_MD5SHA1/* Required for < TLS 1.2 Handshake */
+#  define USE_HMAC_MD5
+
+/**
+    @security MD2 is considered insecure, but is sometimes used for
+    verification of legacy root certificate signatures.
+    @note MD2 signature verification also requires
+    ENABLE_MD5_SIGNED_CERTS and USE_MD5.
+ */
+/* #define USE_MD2 */
+
+/* Please enable, unless using no HMAC algorithms. */
+#  define USE_HMAC
+
+/******************************************************************************/
+/**
+    X.509 Certificates/PKI
+ */
+#  define USE_BASE64_DECODE
+#  define USE_X509/**< Enable minimal X.509 support. */
+#  define USE_CERT_PARSE/**< Enable TBSCertificate parsing. Usually required. @pre USE_X509 */
+#  define USE_FULL_CERT_PARSE/**< @pre USE_CERT_PARSE */
+/**< Support extra distinguished name attributes that SHOULD be supported according to RFC 5280. */
+/* #define USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD */
+/**< Support extra distinguished name attributes not mentioned in RFC 5280. */
+/* #define USE_EXTRA_DN_ATTRIBUTES */
+/* #define ENABLE_CA_CERT_HASH  *//**< Used only for TLS trusted CA ind ext. */
+/* #define ENABLE_MD5_SIGNED_CERTS  *//** @security Accept MD5 signed certs? */
+
+/**
+    @security SHA-1 based signatures are insecure, as SHA-1 can no longer
+    be considered collision resistant (https://shattered.it/static/shattered.pdf).
+    Enable if compatibility with old certificates is required.
+ */
+/* #define ENABLE_SHA1_SIGNED_CERTS */
+
+/**< @security Allow parsing of locally trusted v1 root certs? */
+/* #define ALLOW_VERSION_1_ROOT_CERT_PARSE */
+/**
+    When parsing certificates, always also retain the unparsed DER data.
+    Enabling this has the same effect as setting the
+    CERT_STORE_UNPARSED_BUFFER flag in each psX509ParseCert call.
+ */
+/* #define ALWAYS_KEEP_CERT_DER */
+/**
+   Always attempt to match expectedName with the subject CN, even if
+   a supported, but non-matching subjectAltName was presented.
+   The default behaviour is to check the CN only when no supported SAN
+   was presented, in accordance with Section 6.4.4 of RFC 6125.
+ */
+/* #define ALWAYS_CHECK_SUBJECT_CN_IN_HOSTNAME_VALIDATION */
+#  define USE_CRL/***< @pre USE_FULL_CERT_PARSE */
+#  ifdef USE_CRL
+/**
+   Allow CRL authentication to succeed even when signer CA's cert does not
+   have the keyUsage extension and thus no cRLSign bit.
+   Note that RFC 5280 requires CRL issuer certs to have the keyUsage extension
+   and the cRLSign bit.
+ */
+/* #define ALLOW_CRL_ISSUERS_WITHOUT_KEYUSAGE */
+#  endif
+/**
+   Enable OCSP response and request handling.
+*/
+/* #define USE_OCSP  *//**< @pre USE_SHA1 */
+#  ifdef USE_OCSP
+#    define USE_OCSP_RESPONSE
+#    define USE_OCSP_REQUEST
+#  elif defined(USE_X509) && defined(USE_SHA1)
+/**
+   Enable parsing and writing of OCSP responses. This is enough
+   to support OCSP stapling.
+*/
+#    define USE_OCSP_RESPONSE /**< @pre USE_SHA1 */
+#endif /* USE_OCSP */
+
+/******************************************************************************/
+/**
+    Various PKCS standards support
+ */
+#  define USE_PRIVATE_KEY_PARSING
+#   define USE_PKCS5/**< v2.0 PBKDF encrypted priv keys. @pre USE_3DES */
+/**< Enable PBKDF1 in priv key PEM encryption. @pre USE_PKCS5 and @pre USE_MD5. @security Not recommended. */
+#   define USE_PBKDF1
+#  define USE_PKCS8/* Alternative private key storage format */
+#  define USE_PKCS12/**< @pre USE_PKCS8 */
+#  define USE_PKCS1_OAEP/* OAEP padding algorithm */
+#  define USE_PKCS1_PSS/* PSS padding algorithm */
+
+#endif    /* _h_PS_CRYPTOCONFIG */
+
+/******************************************************************************/
+
diff -ENwbur -x '\.git' orig/matrixssl/crypto/keyformat/asn1fmt.c matrixssl/crypto/keyformat/asn1fmt.c
--- orig/matrixssl/crypto/keyformat/asn1fmt.c	2017-12-15 08:06:04.569104700 +0200
+++ matrixssl/crypto/keyformat/asn1fmt.c	2017-12-15 13:36:20.726062200 +0200
@@ -32,9 +32,9 @@
  */
 /******************************************************************************/
 
-#if !defined USE_X509 && !defined USE_OCSP_RESPONSE
+//#if !defined USE_X509 && !defined USE_OCSP_RESPONSE
 # include "../cryptoImpl.h" /* MatrixSSL API interface and configuration. */
-#endif
+//#endif
 
 #if (defined USE_X509 && defined USE_FULL_CERT_PARSE) || defined USE_OCSP_RESPONSE
 
diff -ENwbur -x '\.git' orig/matrixssl/crypto/keyformat/pkcs.c matrixssl/crypto/keyformat/pkcs.c
--- orig/matrixssl/crypto/keyformat/pkcs.c	2017-12-15 08:06:04.569104700 +0200
+++ matrixssl/crypto/keyformat/pkcs.c	2017-12-15 15:12:25.361780500 +0200
@@ -519,7 +519,8 @@
         if (plen > 0)
         {
             /* Unexpected extra data remains. Treat it as an error. */
-            goto PKCS8_FAIL;
+            psTraceIntCrypto("Unexpected extra data: %d\n", plen);
+            //goto PKCS8_FAIL;
         }
     }
 
diff -ENwbur -x '\.git' orig/matrixssl/crypto/keyformat/x509.h matrixssl/crypto/keyformat/x509.h
--- orig/matrixssl/crypto/keyformat/x509.h	2017-12-15 08:06:04.569104700 +0200
+++ matrixssl/crypto/keyformat/x509.h	2017-12-15 13:36:49.757722700 +0200
@@ -757,7 +757,17 @@
 
 #  ifdef USE_OCSP_RESPONSE
 #   include <time.h>
+
+#   ifdef WIN32
+#    define false   0
+#    define true    1
+
+#    define bool int
+
+#    define timegm _mkgmtime
+#   else
 #   include <stdbool.h>
+#   endif 
 
 /* The default value of allowed mismatch in times in OCSP messages and the local
    clock. */
diff -ENwbur -x '\.git' orig/matrixssl/crypto/math/pstmnt.c matrixssl/crypto/math/pstmnt.c
--- orig/matrixssl/crypto/math/pstmnt.c	2017-12-15 08:06:04.584704700 +0200
+++ matrixssl/crypto/math/pstmnt.c	2017-12-15 07:14:16.168516500 +0200
@@ -648,7 +648,7 @@
     uint64_t value;
 }  __attribute__((__packed__, __aligned__(4))) pstmnt_uint64_aligned4_t;
 
-__extension__ typedef unsigned __int128 pstmntDD_word;
+__extension__ typedef __uint128_t pstmntDD_word;
 
 #  ifndef PSTMNT_VERYLONG_MULADD_CARRY
 #   define PSTMNT_VERYLONG_MULADD_CARRY(uu, u, v, b, a)    \
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/cipherSuite.c matrixssl/matrixssl/cipherSuite.c
--- orig/matrixssl/matrixssl/cipherSuite.c	2017-12-15 08:06:04.678304900 +0200
+++ matrixssl/matrixssl/cipherSuite.c	2017-12-15 10:58:05.752980800 +0200
@@ -2301,10 +2301,44 @@
 #endif /* VALIDATE_KEY_MATERIAL */
 
 
+# ifdef USE_SERVER_SIDE_SSL
+
+# ifdef USE_SERVER_PREFERRED_CIPHERS
+
+/*  quick sort support for sorting descendingly the client's supported
+    supported cipher list
+*/
+void quick_sort_desc(uint32 *v, int l, int r) {
+    int i = l, j = r;
+    int tmp;
+    int p = v[(l + r) / 2];
+
+    while (i <= j) {
+        while (v[i] > p)
+            i++;
+        while (v[j] < p)
+            j--;
+
+        if (i <= j) {
+            tmp = v[i];
+            v[i] = v[j];
+            v[j] = tmp;
+            i++;
+            j--;
+        }
+    };
+
+    if (l < j)
+        quick_sort_desc(v, l, j);
+    if (i < r)
+        quick_sort_desc(v, i, r);
+}
+
+# endif /* USE_SERVER_PREFERRED_CIPHERS */
+
 /*      0 return is a key was found
     <0 is no luck
  */
-# ifdef USE_SERVER_SIDE_SSL
 int32 chooseCipherSuite(ssl_t *ssl, unsigned char *listStart, int32 listLen)
 {
     const sslCipherSpec_t *spec;
@@ -2315,6 +2349,39 @@
     sslPubkeyId_t wantKey;
     sslKeys_t *givenKey = NULL;
 
+# ifdef USE_SERVER_PREFERRED_CIPHERS
+
+#define MAX_CIPHERS 256
+
+    unsigned char           *cc = listStart;
+    unsigned char           *ec = listStart + listLen;
+    uint32                  ciphers[MAX_CIPHERS];
+    int                     ciphersLen = 0, cn = 0, i = 0;
+
+    while ((cc < ec) && (cn < MAX_CIPHERS)) {
+        if (ssl->rec.majVer > SSL2_MAJ_VER) {
+            ciphers[cn] = *cc << 8; cc++;
+            ciphers[cn] += *cc; cc++;
+        } else {
+            /* Deal with an SSLv2 hello message.  Ciphers are 3 bytes long */
+            ciphers[cn] = *cc << 16; cc++;
+            ciphers[cn] += *cc << 8; cc++;
+            ciphers[cn] += *cc; cc++;
+        }
+
+        psTraceIntInfo("Cipher index %d ", cn);
+        psTraceIntInfo("is %d\n", ciphers[cn]);
+
+        cn++;
+    }
+
+    if (cn > 1) quick_sort_desc(ciphers, 0, cn - 1);
+
+    while (i < cn) {
+        cipher = ciphers[i++];
+
+# else
+
     end = c + listLen;
     while (c < end)
     {
@@ -2332,6 +2399,8 @@
             cipher += *c; c++;
         }
 
+# endif /* USE_SERVER_PREFERRED_CIPHERS */
+
         /* Checks if this cipher suite compiled into the library.
             ALSO, in the cases of static server keys (ssl->keys not NULL)
             the haveKeyMaterial function will be run */
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/extDecode.c matrixssl/matrixssl/extDecode.c
--- orig/matrixssl/matrixssl/extDecode.c	2017-12-15 08:06:04.693904900 +0200
+++ matrixssl/matrixssl/extDecode.c	2017-12-15 11:46:55.806570300 +0200
@@ -75,6 +75,7 @@
     ssl->extFlags.session_ticket = 0;
     ssl->extFlags.extended_master_secret = 0;
     ssl->extFlags.status_request = 0;
+    ssl->extFlags.signed_certificate_timestamp = 0;
 
     /*  There could be extension data to parse here:
         Two byte length and extension info.
@@ -676,6 +677,23 @@
         break;
 # endif /* USE_OCSP_RESPONSE */
 
+    /**************************************************************************/
+#ifdef USE_SCT
+    case EXT_SIGNED_CERTIFICATE_TIMESTAMP:
+        /* TODO: add client extension parsing */
+
+        /* Currently, the SCTResponse must be loaded into the key material
+            so we check if that exists to determine if we will reply with
+            the extension */
+        if (ssl->keys->SCTResponseBufLen > 0 &&
+                ssl->keys->SCTResponseBuf != NULL) {
+            ssl->extFlags.signed_certificate_timestamp = 1;
+        } else {
+            psTraceInfo("Client requesting SCT but we have no response\n");
+        }
+
+        break;
+#endif
 
     /**************************************************************************/
 
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/hsDecode.c matrixssl/matrixssl/hsDecode.c
--- orig/matrixssl/matrixssl/hsDecode.c	2017-12-15 08:06:04.693904900 +0200
+++ matrixssl/matrixssl/hsDecode.c	2017-12-15 07:14:16.152916500 +0200
@@ -760,6 +760,11 @@
     }
     else
     {
+        /* Reset the session ID now. If the client specified one and we're
+            sending it back this means a session resumption, which is wrong */
+        memset(ssl->sessionId, 0, SSL_MAX_SESSION_ID_SIZE);
+        ssl->sessionIdLen = 0;
+
 # ifdef USE_DHE_CIPHER_SUITE
         /* If we are DH key exchange we need to generate some keys.  The
             FLAGS_DHE_KEY_EXCH will eventually drive the state matchine to
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/matrixssl.c matrixssl/matrixssl/matrixssl.c
--- orig/matrixssl/matrixssl/matrixssl.c	2017-12-15 08:06:04.693904900 +0200
+++ matrixssl/matrixssl/matrixssl.c	2017-12-15 11:43:58.050403200 +0200
@@ -1130,6 +1130,35 @@
 }
 #endif /* USE_OCSP_RESPONSE && USE_SERVER_SIDE_SSL */
 
+
+#if defined(USE_SCT) && defined(USE_SERVER_SIDE_SSL)
+int32_t matrixSslLoadSCTResponse(sslKeys_t *keys,
+            const unsigned char *SCTResponseBuf, uint16_t SCTResponseBufLen)
+{
+    psPool_t    *pool;
+
+    if (keys == NULL || SCTResponseBuf == NULL || SCTResponseBufLen == 0) {
+        return PS_ARG_FAIL;
+    }
+    pool = keys->pool;
+
+    /* Overwrite/Update any response being set */
+    if (keys->SCTResponseBuf != NULL) {
+        psFree(keys->SCTResponseBuf, pool);
+        keys->SCTResponseBufLen = 0;
+    }
+
+    keys->SCTResponseBufLen = SCTResponseBufLen;
+    if ((keys->SCTResponseBuf = psMalloc(pool, SCTResponseBufLen)) == NULL) {
+        return PS_MEM_FAIL;
+    }
+
+    memcpy(keys->SCTResponseBuf, SCTResponseBuf, SCTResponseBufLen);
+    return PS_SUCCESS;
+}
+#endif /* USE_OCSP && USE_SERVER_SIDE_SSL */
+
+
 /******************************************************************************/
 /*
     This will free the struct and any key material that was loaded via:
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/matrixsslApi.h matrixssl/matrixssl/matrixsslApi.h
--- orig/matrixssl/matrixssl/matrixsslApi.h	2017-12-15 08:06:04.693904900 +0200
+++ matrixssl/matrixssl/matrixsslApi.h	2017-12-15 07:14:16.121716500 +0200
@@ -72,6 +72,7 @@
 # define MATRIXSSL_HANDSHAKE_COMPLETE    5            /* Handshake completed */
 # define MATRIXSSL_RECEIVED_ALERT    6                /* An alert was received */
 # define MATRIXSSL_APP_DATA_COMPRESSED   7            /* App data must be inflated */
+# define MATRIXSSL_ZERO_BUFFER       8                /* matrixSslGetReadbuf returned a zero lengh buffer */
 
 /******************************************************************************/
 /*
@@ -133,7 +134,11 @@
                                            const unsigned char *OCSPResponseBuf,
                                            psSize_t OCSPResponseBufLen);
 # endif
-
+#if defined(USE_SCT) && defined(USE_SERVER_SIDE_SSL)
+PSPUBLIC int32_t matrixSslLoadSCTResponse(sslKeys_t *keys,
+						const unsigned char *SCTResponseBuf,
+						uint16_t SCTResponseBufLen);
+#endif
 /******************************************************************************/
 /*
  *      Essential public APIs
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/matrixsslConfig.h matrixssl/matrixssl/matrixsslConfig.h
--- orig/matrixssl/matrixssl/matrixsslConfig.h	1970-01-01 02:00:00.000000000 +0200
+++ matrixssl/matrixssl/matrixsslConfig.h	2017-12-15 11:41:57.814526100 +0200
@@ -0,0 +1,425 @@
+/**
+ *      @file    matrixsslConfig.h
+ *      @version $Format:%h%d$
+ *
+ *      Configuration settings for building the MatrixSSL library.
+ *      This configuration is intended to be used in FIPS Mode of operation.
+ *      The configuration aims to be compatible with NIST SP 800-52 Rev 1 and
+ *      to enable the most commonly used cipher suites.
+ */
+/*
+ *      Copyright (c) 2013-2017 INSIDE Secure Corporation
+ *      Copyright (c) PeerSec Networks, 2002-2011
+ *      All Rights Reserved
+ *
+ *      The latest version of this code is available at http://www.matrixssl.org
+ *
+ *      This software is open source; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This General Public License does NOT permit incorporating this software
+ *      into proprietary programs.  If you are unable to comply with the GPL, a
+ *      commercial license for this software may be purchased from INSIDE at
+ *      http://www.insidesecure.com/
+ *
+ *      This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *      See the GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *      http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+#ifndef _h_MATRIXSSLCONFIG
+# define _h_MATRIXSSLCONFIG
+
+#  ifdef __cplusplus
+extern "C" {
+#  endif
+
+/**
+    NIST SP 800-52 Rev 1 Conformance.
+    Guidelines for the Selection, Configuration, and Use of Transport Layer
+    Security (TLS) Implementations
+    The key words "shall", "shall not", "should", "should not" and "may"
+    are used as references to the NIST SP 800-52 Rev 1. Algorithms marked as
+    "shall" must not be disabled unless NIST SP 800-52 Rev 1 compatibility
+    is not relevant.
+    @see http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-52r1.pdf
+ */
+
+/******************************************************************************/
+/**
+    Show which SSL messages are created and parsed
+ */
+/* #define USE_SSL_HANDSHAKE_MSG_TRACE */
+
+/**
+    Informational trace that could help pinpoint problems with SSL connections
+ */
+/* #define USE_SSL_INFORMATIONAL_TRACE */
+/* #define USE_DTLS_DEBUG_TRACE */
+
+/******************************************************************************/
+/**
+    Recommended cipher suites.
+    Define the following to enable various cipher suites
+    At least one of these must be defined.  If multiple are defined,
+    the handshake negotiation will determine which is best for the connection.
+    @note Ephemeral ciphersuites offer perfect forward security (PFS)
+    at the cost of a slower TLS handshake.
+ */
+
+/** Ephemeral ECC DH keys, ECC DSA certificates */
+/* #   define USE_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA */ /**< @security NIST_SHOULD */
+/* #   define USE_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA */ /**< @security NIST_MAY */
+/* TLS 1.2 ciphers */
+/* #   define USE_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 */ /**< @security NIST_SHOULD */
+/* #   define USE_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 */ /**< @security NIST_MAY */
+/* #   define USE_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 */ /**< @security NIST_SHOULD */
+/* #   define USE_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 */ /**< @security NIST_SHOULD */
+/** CHACHA20-POLY1305 cipher suites according to RFC 7905. */
+/* #define USE_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 */
+
+/** Ephemeral ECC DH keys, RSA certificates */
+/* #   define USE_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA */ /**< @security NIST_SHOULD */
+/* #   define USE_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA */
+/* TLS 1.2 ciphers */
+/* #   define USE_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 */ /**< @security NIST_SHOULD */
+/* #   define USE_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 */ /**< @security NIST_MAY */
+/* #   define USE_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 */ /**< @security NIST_SHOULD */
+/* #   define USE_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 */ /**< @security NIST_SHOULD */
+/** CHACHA20-POLY1305 cipher suites according to RFC 7905. */
+/* #define USE_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 */
+
+/** Ephemeral Diffie-Hellman ciphersuites, with RSA certificates */
+/* #define USE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA */
+/* #define USE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA */
+/* TLS 1.2 ciphers */
+/* #define USE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 */
+/* #define USE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 */
+
+/** Non-Ephemeral RSA keys/certificates */
+/* #   define USE_TLS_RSA_WITH_AES_128_CBC_SHA */ /**< @security NIST_SHALL */
+/* #   define USE_TLS_RSA_WITH_AES_256_CBC_SHA */ /**< @security NIST_SHOULD */
+/* TLS 1.2 ciphers */
+/* #   define USE_TLS_RSA_WITH_AES_128_CBC_SHA256 */ /**< @security NIST_MAY */
+/* #   define USE_TLS_RSA_WITH_AES_256_CBC_SHA256 */ /**< @security NIST_MAY */
+/* #   define USE_TLS_RSA_WITH_AES_128_GCM_SHA256 */ /**< @security NIST_SHALL */
+/* #   define USE_TLS_RSA_WITH_AES_256_GCM_SHA384 */ /**< @security NIST_SHOULD */
+
+/******************************************************************************/
+/**
+    These cipher suites are secure, but not widely deployed.
+ */
+
+/** Ephemeral Diffie-Hellman ciphersuites, with RSA certificates */
+/* #define USE_SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA */
+
+/** Ephemeral Diffie-Hellman ciphersuites, with PSK authentication */
+/* #define USE_TLS_DHE_PSK_WITH_AES_128_CBC_SHA  *//**< @security NIST_SHOULD_NOT */
+/* #define USE_TLS_DHE_PSK_WITH_AES_256_CBC_SHA  *//**< @security NIST_SHOULD_NOT */
+
+/** Ephemeral ECC DH keys, RSA certificates */
+/* #define USE_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA  *//**< @security NIST_SHOULD */
+
+/** Pre-Shared Key Ciphers.
+    NIST SP 800-52 Rev 1 recommends against using PSK unless neccessary
+    See NIST SP 800-52 Rev 1 Appendix C */
+/* #   define USE_TLS_PSK_WITH_AES_128_CBC_SHA */ /**< @security NIST_SHOULD_NOT */
+/* #   define USE_TLS_PSK_WITH_AES_256_CBC_SHA */ /**< @security NIST_SHOULD_NOT */
+/* TLS 1.2 ciphers */
+/* #   define USE_TLS_PSK_WITH_AES_128_CBC_SHA256 */ /**< @security NIST_SHOULD_NOT */
+/* #   define USE_TLS_PSK_WITH_AES_256_CBC_SHA384 */ /**< @security NIST_SHOULD_NOT */
+
+/** Non-Ephemeral ECC DH keys, ECC DSA certificates */
+/* #   define USE_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA */ /**< @security NIST_MAY */
+/* #   define USE_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA */ /**< @security NIST_MAY */
+/* TLS 1.2 ciphers */
+/* #   define USE_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 */ /**< @security NIST_MAY */
+/* #   define USE_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 */ /**< @security NIST_MAY */
+/* #   define USE_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 */ /**< @security NIST_MAY */
+/* #   define USE_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 */ /**< @security NIST_MAY */
+
+/** Non-Ephemeral ECC DH keys, RSA certificates */
+/* #   define USE_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA */
+/* #   define USE_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA */
+/* TLS 1.2 ciphers */
+/* #   define USE_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 */
+/* #   define USE_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 */
+/* #   define USE_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 */
+/* #   define USE_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 */
+
+/** Non-Ephemeral RSA keys/certificates */
+/* #define USE_SSL_RSA_WITH_3DES_EDE_CBC_SHA  *//**< @security NIST_SHALL */
+
+/** @note Some of (non-mandatory) cipher suites mentioned in NIST SP 800-52
+    Rev 1 are not supported by the MatrixSSL / MatrixDTLS.
+    ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA (NIST SP 800-52 Rev 1 "should")
+    is rarely used cipher suite and is not supported.
+    Also (NIST SP 800-52 Rev 1 "may") TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
+    TLS_DHE_DSS_WITH_* and TLS_RSA_WITH_AES_*_CCM cipher suites cannot be
+    enabled as they are not supported. */
+
+/******************************************************************************/
+/**
+    Ephemeral key cache support.
+    If not using cache, new key exchange keys are created for each TLS session.
+    If using cache, keys are generated initially, and re-used in each
+    subsequent TLS connection within a given time frame and usage count.
+    @see ECC_EPHEMERAL_CACHE_SECONDS and ECC_EPHEMERAL_CACHE_USAGE
+
+    @security Do not cache Ephemeral ECC keys as it is against some standards,
+    including NIST SP 800-56A, when in FIPS 140-2 mode of operation.
+ */
+/* #define NO_ECC_EPHEMERAL_CACHE  *//**< @security NIST_SHALL */
+
+/******************************************************************************/
+/**
+    Configure Support for TLS protocol versions.
+    Define one of:
+        USE_TLS_1_2_AND_ABOVE
+        USE_TLS_1_1_AND_ABOVE
+        USE_TLS_1_0_AND_ABOVE
+    @note There is no option for enabling SSL3.0 at this level
+ */
+/* #define USE_TLS_1_1_AND_ABOVE  *//**< @security default 1_1_AND_ABOVE */
+/* #define USE_TLS_1_2_AND_ABOVE  *//**< @security better than 1_1_AND_ABOVE if no backwards compatiblity concerns */
+/* #define USE_TLS_1_0_AND_ABOVE  *//**< @security no longer recommended. */
+
+/******************************************************************************/
+/**
+    Datagram TLS support.
+    Enables DTLS in addition to TLS.
+    @pre TLS_1_1
+ */
+/* #   define USE_DTLS */
+
+/******************************************************************************/
+/**
+    Compile time support for server or client side SSL
+ */
+#   define USE_CLIENT_SIDE_SSL
+#   define USE_SERVER_SIDE_SSL
+
+/******************************************************************************/
+/**
+    Allow the server to parse SSL 2.0 ClientHello messages even when the
+    server does not actually support SSL 2.0. As per RFC 5246, E.2:
+
+    "... even TLS servers that do not support SSL 2.0 MAY accept version
+    2.0 CLIENT-HELLO messages."
+
+    This option is for compatibility with clients that support
+    SSL 2.0 but are ready to negotiate a higher version such as TLS 1.0.
+    Note that enabling this option will only allow parsing of the SSL 2.0
+    ClientHellos; it will not enable support for the SSL 2.0 protocol.
+    Only 32-byte challenges in the SSL 2.0 ClientHello are supported.
+*/
+#   ifdef USE_SERVER_SIDE_SSL
+/* #define ALLOW_SSLV2_CLIENT_HELLO_PARSE */
+#   endif
+
+/******************************************************************************/
+/**
+    Client certificate authentication
+ */
+#   define USE_CLIENT_AUTH
+
+#   ifdef USE_CLIENT_AUTH
+/**
+    Enable the handshake_messages signature in the CertificateVerify
+    protocol message to be signed using an external module.
+ */
+/* #define USE_EXT_CERTIFICATE_VERIFY_SIGNING */
+#    ifdef USE_EXT_CERTIFICATE_VERIFY_SIGNING
+/**
+    Compile an example external module that allows the
+    USE_EXT_CERTIFICATE_VERIFY_SIGNING feature to be tested using the example
+    client program and sslTest.
+ */
+/* #define USE_EXT_EXAMPLE_MODULE */
+#    endif
+
+/**
+   Enable loading of a new client certificate and private key
+   in response to a CertificateRequest message from a server. This feature
+   allows the client program to e.g. select a client certificate
+   whose issuer is included in the server's list of trusted CAs
+   that was received in the CertificateRequest message.
+*/
+/* #define USE_EXT_CLIENT_CERT_KEY_LOADING */
+#   endif /* USE_CLIENT_AUTH */
+
+/**
+    Enable if the server should send an empty CertificateRequest message if
+    no CA files have been loaded
+ */
+/* #define SERVER_CAN_SEND_EMPTY_CERT_REQUEST */
+
+/**
+    Enabling this define will allow the server to "downgrade" a client auth
+    handshake to a standard handshake if the client replies to a
+    CERTIFICATE_REQUEST with an empty CERTIFICATE message.  The user callback
+    will be called with a NULL cert in this case and the user can determine if
+    the handshake should continue in a non-client auth state.
+ */
+/* #define SERVER_WILL_ACCEPT_EMPTY_CLIENT_CERT_MSG */
+
+/******************************************************************************/
+/**
+    Allow partial parsing of CA certificate bundles. By default, loading of
+    CA files via matrixSslLoadRsaKeys, etc. will fail if the bundle contains
+    a certificate not supported by MatrixSSL's current configuration. When
+    this define is enabled, the parsing of some CA certificates is allowed fail.
+    When parsing of a CA cert fails, a dummy psX509Cert_t with will be added
+    to the CAcerts list. Consult the parseStatus members for details on why
+    the parsing of a specific certificate failed.
+ */
+/* #define ALLOW_CA_BUNDLE_PARTIAL_PARSE */
+
+/******************************************************************************/
+/**
+    Enable the Application Layer Protocol Negotiation extension.
+    Servers and Clients will still have to use the required public API to
+    set protocols and register application callbacks to negotiate the
+    protocol that will be tunneled over TLS.
+    @see ALPN section in the developer's guide for information.
+ */
+/* #define USE_ALPN */
+
+/******************************************************************************/
+/**
+    Enable the Trusted CA Indication CLIENT_HELLO extension.  Will send the
+    sha1 hash of each CA file to the server for help in server selection.
+    This extra level of define is to help isolate the SHA1 requirement
+ */
+/* #define USE_TRUSTED_CA_INDICATION  *//**< @security NIST_SHOULD */
+
+/******************************************************************************/
+/**
+    A client side configuration that requires a server to provide an OCSP
+    response if the client uses the certitificate status request extension.
+    The "must staple" terminology is typically associated with certificates
+    at the X.509 layer but it is a good description of what is being required
+    of the server at the TLS level.
+    @pre USE_OCSP_RESPONSE must be enabled at the crypto level and the client
+    application must use the OCSPstapling session option at run time for this
+    setting to have any effect
+ */
+#   ifdef USE_OCSP_RESPONSE
+#    define USE_OCSP_MUST_STAPLE /**< @security NIST_SHALL */
+#   endif
+
+/******************************************************************************/
+/**
+    Rehandshaking support.
+
+    Enabling USE_REHANDSHAKING will allow secure-rehandshakes using the
+    protocol defined in RFC 5748 which fixed a critical exploit in
+    the standard TLS specification.
+
+    @security Looking towards TLS 1.3, which removes re-handshaking, this
+    feature is disabled by default.
+ */
+/* #define USE_REHANDSHAKING */
+
+/******************************************************************************//**
+    False Start support for Chrome and Firefox browsers.
+    @see https://tools.ietf.org/html/rfc7918
+
+    Some versions of Firefox browser and Chrome browser include support for
+    False Start. This flag will enable server side support on MatrixSSL
+    operating as server for client using false start feature.
+
+    @note April 2012: Google has announced this feature will be removed in
+    version 20 of their browser due to industry compatibility issues.
+    However because there are other browsers using the feature, this feature
+    is often recommendable to enable for maximal browser compatibility.
+ */
+#   define USE_SERVER_SIDE_FALSE_START_SUPPORT
+
+/******************************************************************************/
+/**
+	Uncomment to enable the Certificate Transparency TLS extension.
+ */
+/* #define USE_SCT */
+
+/******************************************************************************/
+/**
+	Only available server side. Allows matrixSSL to chose the strongest cipher
+	from the client's supported list.
+*/
+/* #define USE_SERVER_PREFERRED_CIPHERS */
+
+/******************************************************************************/
+/**
+    If SERVER you may define the number of sessions to cache and how
+    long a session will remain valid in the cache from first access.
+    Session caching enables very fast "session resumption handshakes".
+
+    SSL_SESSION_TABLE_SIZE minimum value is 1
+    SSL_SESSION_ENTRY_LIFE is in milliseconds, minimum 0
+
+    @note Session caching can be disabled by setting SSL_SESSION_ENTRY_LIFE to 0
+    however, this will also immediately expire SESSION_TICKETS below.
+ */
+#   ifdef USE_SERVER_SIDE_SSL
+#    define SSL_SESSION_TABLE_SIZE 32
+#    define SSL_SESSION_ENTRY_LIFE (86400 * 1000)/* one day, in milliseconds */
+#   endif
+
+/******************************************************************************/
+/**
+    Use RFC 5077 session resumption mechanism. The SSL_SESSION_ENTRY_LIFE
+    define applies to this method as well as the standard method. The
+    SSL_SESSION_TICKET_LIST_LEN is the max size of the server key list.
+ */
+#   define USE_STATELESS_SESSION_TICKETS
+#   define SSL_SESSION_TICKET_LIST_LEN 32
+
+/******************************************************************************/
+/**
+    The initial buffer sizes for send and receive buffers in each ssl_t session.
+    Buffers are internally grown if more incoming or outgoing data storage is
+    needed, up to a maximum of SSL_MAX_BUF_SIZE. Once the memory used by the
+    buffer again drops below SSL_DEFAULT_X_BUF_SIZE, the buffer will be reduced
+    to this size. Most standard SSL handshakes require on the order of 1024 B.
+
+    SSL_DEFAULT_x_BUF_SIZE      value in bytes, maximum SSL_MAX_BUF_SIZE
+ */
+#   ifndef USE_DTLS
+#     ifndef SSL_DEFAULT_IN_BUF_SIZE
+#       define SSL_DEFAULT_IN_BUF_SIZE     1500        /* Base recv buf size, bytes */
+#     endif
+#     ifndef SSL_DEFAULT_OUT_BUF_SIZE
+#       define SSL_DEFAULT_OUT_BUF_SIZE    1500        /* Base send buf size, bytes */
+#     endif
+#   else
+/******************************************************************************/
+/**
+    The Path Maximum Transmission Unit is the largest datagram that can be
+    sent or recieved.  It is beyond the scope of DTLS to negotiate this value
+    so make sure both sides have agreed on this value.  This is an enforced
+    limitation in MatrixDTLS so connections will not succeed if a peer has a
+    PTMU set larger than this value.
+ */
+#    define DTLS_PMTU  1500                       /* 1500 Default/Maximum datagram len */
+#    define SSL_DEFAULT_IN_BUF_SIZE     DTLS_PMTU /* See PMTU comments above */
+#    define SSL_DEFAULT_OUT_BUF_SIZE    DTLS_PMTU /* See PMTU comments above */
+
+/* #define DTLS_SEND_RECORDS_INDIVIDUALLY  *//* Max one record per datagram */
+#   endif
+
+#  ifdef __cplusplus
+}
+#  endif
+
+#endif  /* _h_MATRIXCONFIG */
+/******************************************************************************/
+
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/matrixssllib.h matrixssl/matrixssl/matrixssllib.h
--- orig/matrixssl/matrixssl/matrixssllib.h	2017-12-15 08:06:04.693904900 +0200
+++ matrixssl/matrixssl/matrixssllib.h	2017-12-15 07:14:16.121716500 +0200
@@ -1029,6 +1029,10 @@
     unsigned char *OCSPResponseBuf;
     psSize_t OCSPResponseBufLen;
 # endif
+#if defined(USE_SCT) && defined(USE_SERVER_SIDE_SSL)
+    unsigned char *SCTResponseBuf;
+    uint16_t SCTResponseBufLen;
+#endif
     void *poolUserPtr;              /* Data that will be given to psOpenPool
                                        for any operations involving these keys */
 # if defined(USE_ECC) || defined(REQUIRE_DH_PARAMS)
@@ -1596,6 +1600,7 @@
         uint32 session_ticket : 1;
         uint32 status_request : 1;                 /* received EXT_STATUS_REQUEST */
         uint32 status_request_v2 : 1;              /* received EXT_STATUS_REQUEST_V2 */
+        uint32 signed_certificate_timestamp: 1;    /* received EXT_SIGNED_CERTIFICATE_TIMESTAMP */
         uint32 require_extended_master_secret : 1; /* peer may require */
         /* For renegotiations. */
         uint32 sni_in_last_client_hello : 1;
diff -ENwbur -x '\.git' orig/matrixssl/matrixssl/sslEncode.c matrixssl/matrixssl/sslEncode.c
--- orig/matrixssl/matrixssl/sslEncode.c	2017-12-15 08:06:04.693904900 +0200
+++ matrixssl/matrixssl/sslEncode.c	2017-12-15 07:26:36.268508800 +0200
@@ -39,7 +39,9 @@
 # ifndef USE_ONLY_PSK_CIPHER_SUITE
 static int32 writeCertificate(ssl_t *ssl, sslBuf_t *out, int32 notEmpty);
 #  if defined(USE_OCSP_RESPONSE) && defined(USE_SERVER_SIDE_SSL)
+static int32 writeCertificateStatusOrig(ssl_t *ssl, sslBuf_t *out);
 static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out);
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out);
 #  endif
 # endif
 static int32 writeChangeCipherSpec(ssl_t *ssl, sslBuf_t *out);
@@ -1673,6 +1675,11 @@
             extSize = 2;
             messageSize += 4; /* 2 type, 2 length, 0 value */
 
+            if (ssl->hshakeHeadLen + ssl->recordHeadLen + 4 + ssl->keys->OCSPResponseBufLen > ssl->maxPtFrag) {
+                messageSize += addCertFragOverhead(ssl, ssl->hshakeHeadLen + ssl->recordHeadLen + 4 +
+                                                   ssl->keys->OCSPResponseBufLen);
+            }
+
             /* And the handshake message oh.  1 type, 3 len, x OCSPResponse
                 The status_request flag will only have been set if a
                 ssl->keys->OCSPResponseBuf was present during extension parse */
@@ -1682,6 +1689,13 @@
         }
 #  endif /* USE_OCSP_RESPONSE */
 
+#ifdef USE_SCT
+        if (ssl->extFlags.signed_certificate_timestamp) {
+            extSize = 2;
+            messageSize += 2 + 2 + 2 + ssl->keys->SCTResponseBufLen; /* 2 type, 2 length, data */
+        }
+#endif
+
 #  ifdef USE_STATELESS_SESSION_TICKETS
         if (ssl->sid &&
             ssl->sid->sessionTicketState == SESS_TICKET_STATE_RECVD_EXT)
@@ -3822,6 +3836,15 @@
     }
 #  endif /* USE_OCSP_RESPONSE */
 
+#  ifdef USE_SCT
+    if (ssl->extFlags.signed_certificate_timestamp) {
+        if (extLen == 0) {
+            extLen = 2;
+        }
+        extLen += 2 + 2 + 2 + ssl->keys->SCTResponseBufLen; /* 2 type, 2 len, data */
+    }
+#  endif
+
 #  ifdef USE_ALPN
     if (ssl->alpnLen)
     {
@@ -4017,6 +4040,20 @@
         }
 #  endif /* USE_OCSP_RESPONSE */
 
+#  ifdef USE_SCT
+        if (ssl->extFlags.signed_certificate_timestamp)
+        {
+            *c = (EXT_SIGNED_CERTIFICATE_TIMESTAMP & 0xFF00) >> 8; c++;
+            *c = EXT_SIGNED_CERTIFICATE_TIMESTAMP & 0xFF; c++;
+            *c = ((ssl->keys->SCTResponseBufLen + 2) & 0xFF00) >> 8; c++;
+            *c = (ssl->keys->SCTResponseBufLen + 2) & 0xFF; c++;
+            *c = (ssl->keys->SCTResponseBufLen & 0xFF00) >> 8; c++;
+            *c = ssl->keys->SCTResponseBufLen & 0xFF; c++;
+            memcpy(c, ssl->keys->SCTResponseBuf, ssl->keys->SCTResponseBufLen);
+            c += ssl->keys->SCTResponseBufLen;
+	}
+#  endif
+
 #  ifdef USE_ALPN
         if (ssl->alpnLen)
         {
@@ -5101,7 +5138,7 @@
 
 
 #  if defined(USE_OCSP_RESPONSE) && defined(USE_SERVER_SIDE_SSL)
-static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+static int32 writeCertificateStatusOrig(ssl_t *ssl, sslBuf_t *out)
 {
     unsigned char *c, *end, *encryptStart;
     uint8_t padLen;
@@ -5154,6 +5191,221 @@
     return MATRIXSSL_SUCCESS;
 
 }
+
+#define CERTIFICATE_STATUS_OCSP        1
+
+/*
+    A fragmented write of the CERTIFICATE_STATUS handhshake message.  This is one
+    of the handshake messages that supports fragmentation because it is one of the
+    messages where the 512byte plaintext max of the max_fragment extension can
+    be exceeded.
+*/
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+    unsigned char *DER;
+    unsigned char *c, *end, *encryptStart;
+    uint8_t padLen;
+    psSize_t messageSize, rc, DERLen;
+    int32 midWrite, midSizeWrite, countDown, firstOne = 1;
+    int32 lsize;
+
+    c = out->end;
+    end = out->buf + out->size;
+
+    midSizeWrite = midWrite = 0;
+    DER = ssl->keys->OCSPResponseBuf;
+    DERLen = ssl->keys->OCSPResponseBufLen;
+
+    lsize = 1 + 3; // 1 byte OCSP status type + 3 bytes DER length;
+
+    while (DERLen > 0) {
+        if (firstOne) {
+            firstOne = 0;
+            countDown = ssl->maxPtFrag;
+
+            messageSize = DERLen + lsize + ssl->recordHeadLen + ssl->hshakeHeadLen;
+            if ((rc = writeRecordHeader(ssl,
+                    SSL_RECORD_TYPE_HANDSHAKE_FIRST_FRAG, SSL_HS_CERTIFICATE_STATUS,
+                    &messageSize, &padLen, &encryptStart, end, &c)) < 0) {
+                return rc;
+            }
+
+            // Write the status type
+            *c = CERTIFICATE_STATUS_OCSP; c++;
+
+            // Account for what has been written so far
+            countDown -= ssl->hshakeHeadLen + 1;
+
+            midWrite = 0;
+            if (countDown < 3) {
+                /* Fragment falls right on DER len write.  Has
+                    to be at least one byte or countDown would have
+                    been 0 and got us out of here already*/
+                *c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+                c++; countDown--;
+                midSizeWrite = 2;
+                if (countDown != 0) {
+                    *c = (DERLen & 0xFF00) >> 8; c++; countDown--;
+                    midSizeWrite = 1;
+                    if (countDown != 0) {
+                        *c = (DERLen & 0xFF); c++; countDown--;
+                        midSizeWrite = 0;
+                    }
+                }
+                goto postpone_and_next;
+            } else {
+                *c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+                c++;
+                *c = (DERLen & 0xFF00) >> 8; c++;
+                *c = (DERLen & 0xFF); c++;
+                countDown -= 3;
+            }
+            midWrite = min(DERLen, countDown);
+            memcpy(c, DER, midWrite);
+            DERLen -= midWrite;
+            c += midWrite;
+            countDown -= midWrite;
+
+            postpone_and_next:
+            if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                    SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+                    &c)) < 0) {
+                return rc;
+            }
+
+            out->end = c;
+        } else {
+ /*
+            Not-first fragments
+ */
+            if (midSizeWrite > 0) {
+                messageSize = midSizeWrite;
+            } else {
+                messageSize = 0;
+            }
+            if ((DERLen + messageSize) > ssl->maxPtFrag) {
+                messageSize += ssl->maxPtFrag;
+            } else {
+                messageSize += DERLen;
+            }
+
+            countDown = messageSize;
+            messageSize += ssl->recordHeadLen;
+            /* Second, etc... */
+            if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE_FRAG,
+                    SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+                    end, &c)) < 0) {
+                return rc;
+            }
+
+            if (midSizeWrite > 0) {
+                if (midSizeWrite == 2) {
+                    *c = (DERLen & 0xFF00) >> 8; c++;
+                    *c = (DERLen & 0xFF); c++;
+                    countDown -= 2;
+                } else {
+                    *c = (DERLen & 0xFF); c++;
+                    countDown -= 1;
+                }
+                midSizeWrite = 0;
+            }
+
+            if (countDown < DERLen) {
+                memcpy(c, DER + midWrite, countDown);
+                DERLen -= countDown;
+                c += countDown;
+                midWrite += countDown;
+                countDown = 0;
+            } else {
+                memcpy(c, DER + midWrite, DERLen);
+                c += DERLen;
+                countDown -= DERLen;
+                DERLen -= DERLen;
+            }
+
+            if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                    SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+                    &c)) < 0) {
+                return rc;
+            }
+            out->end = c;
+        }
+    }
+
+    out->end = c;
+    return MATRIXSSL_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+    Write a Certificate Status message.
+    The encoding of the message is as follows:
+        1 byte status type
+        3 byte length of DER data (network byte order)
+        x bytes DER data
+*/
+static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+    unsigned char *DER;
+    uint32 DERLen;
+
+    unsigned char *c, *end, *encryptStart;
+    uint8_t padLen;
+    psSize_t lsize, messageSize, rc;
+
+    /* Easier to exclude this message internally rather than futher muddy the
+        numerous #ifdef and ssl_t tests in the caller */
+    if (ssl->extFlags.status_request == 0)
+    {
+        return MATRIXSSL_SUCCESS;
+    }
+
+    psTraceHs("<<< server creating CERTIFICATE_STATUS  message\n");
+
+    c = out->end;
+    end = out->buf + out->size;
+
+    DERLen = ssl->keys->OCSPResponseBufLen;
+    lsize = 1 + 3;  // 1 byte status type + 3 bytes DER length
+
+    /* TODO DTLS: Make sure this maxPtFrag is consistent with the fragment
+        extension and is not interfering with DTLS notions of fragmentation */
+    if ((DERLen + lsize + ssl->hshakeHeadLen) > ssl->maxPtFrag) {
+        return writeMultiRecordCertificateStatus(ssl, out);
+    } else {
+        messageSize =
+            ssl->recordHeadLen +
+            ssl->hshakeHeadLen +
+            lsize + DERLen;
+
+        if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+                end, &c)) < 0) {
+            return rc;
+        }
+
+        // Write out status type
+        *c = CERTIFICATE_STATUS_OCSP; c++;
+
+        // Write out DER length and DER
+        DER = ssl->keys->OCSPResponseBuf;
+        if (DERLen > 0) {
+            *c = (unsigned char)((DERLen & 0xFF0000) >> 16); c++;
+            *c = (DERLen & 0xFF00) >> 8; c++;
+            *c = (DERLen & 0xFF); c++;
+            memcpy(c, DER, DERLen);
+            c += DERLen;
+        }
+
+        if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+                &c)) < 0) {
+            return rc;
+        }
+        out->end = c;
+    }
+    return MATRIXSSL_SUCCESS;
+}
 #  endif /* OCSP && SERVER_SIDE_SSL */
 
 /******************************************************************************/
