diff --git a/matrixssl/matrixsslConfig.h b/matrixssl/matrixsslConfig.h
index 976d4eb..155c1f6 100644
--- a/matrixssl/matrixsslConfig.h
+++ b/matrixssl/matrixsslConfig.h
@@ -96,20 +96,20 @@ extern "C" {
 //#define USE_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
 
 /** Ephemeral Diffie-Hellman ciphersuites, with RSA certificates */
-#define USE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
-#define USE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
+//#define USE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
+//#define USE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
 /* TLS 1.2 ciphers */
-#define USE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
-#define USE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
+//#define USE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
+//#define USE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
 
 /** Non-Ephemeral RSA keys/certificates */
-#define USE_TLS_RSA_WITH_AES_128_CBC_SHA/**< @security NIST_SHALL */
-#define USE_TLS_RSA_WITH_AES_256_CBC_SHA/**< @security NIST_SHOULD */
+//#define USE_TLS_RSA_WITH_AES_128_CBC_SHA/**< @security NIST_SHALL */
+//#define USE_TLS_RSA_WITH_AES_256_CBC_SHA/**< @security NIST_SHOULD */
 /* TLS 1.2 ciphers */
-#define USE_TLS_RSA_WITH_AES_128_CBC_SHA256/**< @security NIST_MAY */
-#define USE_TLS_RSA_WITH_AES_256_CBC_SHA256/**< @security NIST_MAY */
-#define USE_TLS_RSA_WITH_AES_128_GCM_SHA256/**< @security NIST_SHALL */
-#define USE_TLS_RSA_WITH_AES_256_GCM_SHA384/**< @security NIST_SHOULD */
+//#define USE_TLS_RSA_WITH_AES_128_CBC_SHA256/**< @security NIST_MAY */
+//#define USE_TLS_RSA_WITH_AES_256_CBC_SHA256/**< @security NIST_MAY */
+//#define USE_TLS_RSA_WITH_AES_128_GCM_SHA256/**< @security NIST_SHALL */
+//#define USE_TLS_RSA_WITH_AES_256_GCM_SHA384/**< @security NIST_SHOULD */
 
 /******************************************************************************/
 /**
@@ -120,8 +120,8 @@ extern "C" {
 //#define USE_SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA
 
 /** Ephemeral Diffie-Hellman ciphersuites, with PSK authentication */
-#define USE_TLS_DHE_PSK_WITH_AES_128_CBC_SHA/**< @security NIST_SHOULD_NOT */
-#define USE_TLS_DHE_PSK_WITH_AES_256_CBC_SHA/**< @security NIST_SHOULD_NOT */
+//#define USE_TLS_DHE_PSK_WITH_AES_128_CBC_SHA/**< @security NIST_SHOULD_NOT */
+//#define USE_TLS_DHE_PSK_WITH_AES_256_CBC_SHA/**< @security NIST_SHOULD_NOT */
 
 /** Ephemeral ECC DH keys, RSA certificates */
 //#define USE_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA /**< @security NIST_SHOULD */
@@ -129,11 +129,11 @@ extern "C" {
 /** Pre-Shared Key Ciphers.
 	NIST SP 800-52 Rev 1 recommends against using PSK unless neccessary
     See NIST SP 800-52 Rev 1 Appendix C */
-#define USE_TLS_PSK_WITH_AES_128_CBC_SHA/**< @security NIST_SHOULD_NOT */
-#define USE_TLS_PSK_WITH_AES_256_CBC_SHA/**< @security NIST_SHOULD_NOT */
+//#define USE_TLS_PSK_WITH_AES_128_CBC_SHA/**< @security NIST_SHOULD_NOT */
+//#define USE_TLS_PSK_WITH_AES_256_CBC_SHA/**< @security NIST_SHOULD_NOT */
 /* TLS 1.2 ciphers */
-#define USE_TLS_PSK_WITH_AES_128_CBC_SHA256/**< @security NIST_SHOULD_NOT */
-#define USE_TLS_PSK_WITH_AES_256_CBC_SHA384/**< @security NIST_SHOULD_NOT */
+//#define USE_TLS_PSK_WITH_AES_128_CBC_SHA256/**< @security NIST_SHOULD_NOT */
+//#define USE_TLS_PSK_WITH_AES_256_CBC_SHA384/**< @security NIST_SHOULD_NOT */
 
 /** Non-Ephemeral ECC DH keys, ECC DSA certificates */
 //#define USE_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA /**< @security NIST_MAY */
@@ -186,7 +186,7 @@ extern "C" {
 		USE_TLS_1_0_AND_ABOVE
 	@note There is no option for enabling SSL3.0 at this level
 */
-#define USE_TLS_1_1_AND_ABOVE/**< @security default 1_1_AND_ABOVE */
+//#define USE_TLS_1_1_AND_ABOVE/**< @security default 1_1_AND_ABOVE */
 //#define USE_TLS_1_2_AND_ABOVE /**< @security better than 1_1_AND_ABOVE if no backwards compatiblity concerns */
 //#define USE_TLS_1_0_AND_ABOVE /**< @security no longer recommended. */
 
@@ -196,7 +196,7 @@ extern "C" {
 	Enables DTLS in addition to TLS.
 	@pre TLS_1_1
 */
-#define USE_DTLS
+//#define USE_DTLS
 
 /******************************************************************************/
 /**
@@ -298,8 +298,8 @@ extern "C" {
 	however, this will also immediately expire SESSION_TICKETS below.
 */
 #ifdef USE_SERVER_SIDE_SSL
-#define SSL_SESSION_TABLE_SIZE 32
-#define SSL_SESSION_ENTRY_LIFE (86400*1000)/* one day, in milliseconds */
+//#define SSL_SESSION_TABLE_SIZE 32
+//#define SSL_SESSION_ENTRY_LIFE (86400*1000)/* one day, in milliseconds */
 #endif
 
 /******************************************************************************/
@@ -308,8 +308,8 @@ extern "C" {
 	define applies to this method as well as the standard method. The
 	SSL_SESSION_TICKET_LIST_LEN is the max size of the server key list.
 */
-#define USE_STATELESS_SESSION_TICKETS
-#define SSL_SESSION_TICKET_LIST_LEN 32
+//#define USE_STATELESS_SESSION_TICKETS
+//#define SSL_SESSION_TICKET_LIST_LEN 32
 
 /******************************************************************************/
 /**
@@ -322,8 +322,8 @@ extern "C" {
 	SSL_DEFAULT_x_BUF_SIZE	value in bytes, maximum SSL_MAX_BUF_SIZE
  */
 #ifndef USE_DTLS
-#can_define	SSL_DEFAULT_IN_BUF_SIZE		1500		/* Base recv buf size, bytes */
-#can_define	SSL_DEFAULT_OUT_BUF_SIZE	1500		/* Base send buf size, bytes */
+//#can_define	SSL_DEFAULT_IN_BUF_SIZE		1500		/* Base recv buf size, bytes */
+//#can_define	SSL_DEFAULT_OUT_BUF_SIZE	1500		/* Base send buf size, bytes */
 #else
 /******************************************************************************/
 /**

diff --git a/crypto/keyformat/pkcs.c b/crypto/keyformat/pkcs.c
index f1a725e..afb537f 100644
--- a/crypto/keyformat/pkcs.c
+++ b/crypto/keyformat/pkcs.c
@@ -519,7 +519,8 @@ int32 psPkcs8ParsePrivBin(psPool_t *pool, unsigned char *buf, int32 size,
         if (plen > 0)
         {
             /* Unexpected extra data remains. Treat it as an error. */
-            goto PKCS8_FAIL;
+            psTraceIntCrypto("Unexpected extra data: %d\n", plen);
+            //goto PKCS8_FAIL;
         }
     }

diff --git a/matrixssl/hsDecode.c b/matrixssl/hsDecode.c
index 0545339..deeb9af 100644
--- a/matrixssl/hsDecode.c
+++ b/matrixssl/hsDecode.c
@@ -658,6 +658,11 @@ SKIP_STANDARD_RESUMPTION:
     }
     else
     {
+        /* Reset the session ID now. If the client specified one and we're
+            sending it back this means a session resumption, which is wrong */
+        memset(ssl->sessionId, 0, SSL_MAX_SESSION_ID_SIZE);
+        ssl->sessionIdLen = 0;
+
 # ifdef USE_DHE_CIPHER_SUITE
         /* If we are DH key exchange we need to generate some keys.  The
             FLAGS_DHE_KEY_EXCH will eventually drive the state matchine to

diff --git a/matrixssl/matrixsslApi.h b/matrixssl/matrixsslApi.h
index 2d9fc17..a3dbdf0 100644
--- a/matrixssl/matrixsslApi.h
+++ b/matrixssl/matrixsslApi.h
@@ -72,6 +72,7 @@ extern "C" {
 # define MATRIXSSL_HANDSHAKE_COMPLETE    5            /* Handshake completed */
 # define MATRIXSSL_RECEIVED_ALERT    6                /* An alert was received */
 # define MATRIXSSL_APP_DATA_COMPRESSED   7            /* App data must be inflated */
+# define MATRIXSSL_ZERO_BUFFER       8                /* matrixSslGetReadbuf returned a zero lengh buffer */
 
 /******************************************************************************/
 /*

diff --git a/matrixssl/sslEncode.c b/matrixssl/sslEncode.c
index 92955f4..a5687b2 100644
--- a/matrixssl/sslEncode.c
+++ b/matrixssl/sslEncode.c
@@ -39,7 +39,9 @@
 # ifndef USE_ONLY_PSK_CIPHER_SUITE
 static int32 writeCertificate(ssl_t *ssl, sslBuf_t *out, int32 notEmpty);
 #  if defined(USE_OCSP) && defined(USE_SERVER_SIDE_SSL)
+static int32 writeCertificateStatusOrig(ssl_t *ssl, sslBuf_t *out);
 static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out);
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out);
 #  endif
 # endif
 static int32 writeChangeCipherSpec(ssl_t *ssl, sslBuf_t *out);
@@ -1673,6 +1675,11 @@ int32 sslEncodeResponse(ssl_t *ssl, psBuf_t *out, uint32 *requiredLen)
             extSize = 2;
             messageSize += 4; /* 2 type, 2 length, 0 value */
 
+            if (ssl->hshakeHeadLen + ssl->recordHeadLen + 4 + ssl->keys->OCSPResponseBufLen > ssl->maxPtFrag) {
+                messageSize += addCertFragOverhead(ssl, ssl->hshakeHeadLen + ssl->recordHeadLen + 4 +
+                                                   ssl->keys->OCSPResponseBufLen);
+            }
+
             /* And the handshake message oh.  1 type, 3 len, x OCSPResponse
                 The status_request flag will only have been set if a
                 ssl->keys->OCSPResponseBuf was present during extension parse */
@@ -5111,7 +5118,7 @@ static int32 writeMultiRecordCertificate(ssl_t *ssl, sslBuf_t *out,
 
 
 #  if defined(USE_OCSP) && defined(USE_SERVER_SIDE_SSL)
-static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+static int32 writeCertificateStatusOrig(ssl_t *ssl, sslBuf_t *out)
 {
     unsigned char *c, *end, *encryptStart;
     uint8_t padLen;
@@ -5164,6 +5171,221 @@ static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out)
     return MATRIXSSL_SUCCESS;
 
 }
+
+#define CERTIFICATE_STATUS_OCSP        1
+
+/*
+    A fragmented write of the CERTIFICATE_STATUS handhshake message.  This is one
+    of the handshake messages that supports fragmentation because it is one of the
+    messages where the 512byte plaintext max of the max_fragment extension can
+    be exceeded.
+*/
+static int32 writeMultiRecordCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+    unsigned char *DER;
+    unsigned char *c, *end, *encryptStart;
+    uint8_t padLen;
+    psSize_t messageSize, rc, DERLen;
+    int32 midWrite, midSizeWrite, countDown, firstOne = 1;
+    int32 lsize;
+
+    c = out->end;
+    end = out->buf + out->size;
+
+    midSizeWrite = midWrite = 0;
+    DER = ssl->keys->OCSPResponseBuf;
+    DERLen = ssl->keys->OCSPResponseBufLen;
+
+    lsize = 1 + 3; // 1 byte OCSP status type + 3 bytes DER length;
+
+    while (DERLen > 0) {
+        if (firstOne) {
+            firstOne = 0;
+            countDown = ssl->maxPtFrag;
+
+            messageSize = DERLen + lsize + ssl->recordHeadLen + ssl->hshakeHeadLen;
+            if ((rc = writeRecordHeader(ssl,
+                    SSL_RECORD_TYPE_HANDSHAKE_FIRST_FRAG, SSL_HS_CERTIFICATE_STATUS,
+                    &messageSize, &padLen, &encryptStart, end, &c)) < 0) {
+                return rc;
+            }
+
+            // Write the status type
+            *c = CERTIFICATE_STATUS_OCSP; c++;
+
+            // Account for what has been written so far
+            countDown -= ssl->hshakeHeadLen + 1;
+
+            midWrite = 0;
+            if (countDown < 3) {
+                /* Fragment falls right on DER len write.  Has
+                    to be at least one byte or countDown would have
+                    been 0 and got us out of here already*/
+                *c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+                c++; countDown--;
+                midSizeWrite = 2;
+                if (countDown != 0) {
+                    *c = (DERLen & 0xFF00) >> 8; c++; countDown--;
+                    midSizeWrite = 1;
+                    if (countDown != 0) {
+                        *c = (DERLen & 0xFF); c++; countDown--;
+                        midSizeWrite = 0;
+                    }
+                }
+                goto postpone_and_next;
+            } else {
+                *c = (unsigned char)((DERLen & 0xFF0000) >> 16);
+                c++;
+                *c = (DERLen & 0xFF00) >> 8; c++;
+                *c = (DERLen & 0xFF); c++;
+                countDown -= 3;
+            }
+            midWrite = min(DERLen, countDown);
+            memcpy(c, DER, midWrite);
+            DERLen -= midWrite;
+            c += midWrite;
+            countDown -= midWrite;
+
+            postpone_and_next:
+            if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                    SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+                    &c)) < 0) {
+                return rc;
+            }
+
+            out->end = c;
+        } else {
+ /*
+            Not-first fragments
+ */
+            if (midSizeWrite > 0) {
+                messageSize = midSizeWrite;
+            } else {
+                messageSize = 0;
+            }
+            if ((DERLen + messageSize) > ssl->maxPtFrag) {
+                messageSize += ssl->maxPtFrag;
+            } else {
+                messageSize += DERLen;
+            }
+
+            countDown = messageSize;
+            messageSize += ssl->recordHeadLen;
+            /* Second, etc... */
+            if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE_FRAG,
+                    SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+                    end, &c)) < 0) {
+                return rc;
+            }
+
+            if (midSizeWrite > 0) {
+                if (midSizeWrite == 2) {
+                    *c = (DERLen & 0xFF00) >> 8; c++;
+                    *c = (DERLen & 0xFF); c++;
+                    countDown -= 2;
+                } else {
+                    *c = (DERLen & 0xFF); c++;
+                    countDown -= 1;
+                }
+                midSizeWrite = 0;
+            }
+
+            if (countDown < DERLen) {
+                memcpy(c, DER + midWrite, countDown);
+                DERLen -= countDown;
+                c += countDown;
+                midWrite += countDown;
+                countDown = 0;
+            } else {
+                memcpy(c, DER + midWrite, DERLen);
+                c += DERLen;
+                countDown -= DERLen;
+                DERLen -= DERLen;
+            }
+
+            if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                    SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+                    &c)) < 0) {
+                return rc;
+            }
+            out->end = c;
+        }
+    }
+
+    out->end = c;
+    return MATRIXSSL_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+    Write a Certificate Status message.
+    The encoding of the message is as follows:
+        1 byte status type
+        3 byte length of DER data (network byte order)
+        x bytes DER data
+*/
+static int32 writeCertificateStatus(ssl_t *ssl, sslBuf_t *out)
+{
+    unsigned char *DER;
+    uint32 DERLen;
+
+    unsigned char *c, *end, *encryptStart;
+    uint8_t padLen;
+    psSize_t lsize, messageSize, rc;
+
+    /* Easier to exclude this message internally rather than futher muddy the
+        numerous #ifdef and ssl_t tests in the caller */
+    if (ssl->extFlags.status_request == 0)
+    {
+        return MATRIXSSL_SUCCESS;
+    }
+
+    psTraceHs("<<< server creating CERTIFICATE_STATUS  message\n");
+
+    c = out->end;
+    end = out->buf + out->size;
+
+    DERLen = ssl->keys->OCSPResponseBufLen;
+    lsize = 1 + 3;  // 1 byte status type + 3 bytes DER length
+
+    /* TODO DTLS: Make sure this maxPtFrag is consistent with the fragment
+        extension and is not interfering with DTLS notions of fragmentation */
+    if ((DERLen + lsize + ssl->hshakeHeadLen) > ssl->maxPtFrag) {
+        return writeMultiRecordCertificateStatus(ssl, out);
+    } else {
+        messageSize =
+            ssl->recordHeadLen +
+            ssl->hshakeHeadLen +
+            lsize + DERLen;
+
+        if ((rc = writeRecordHeader(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                SSL_HS_CERTIFICATE_STATUS, &messageSize, &padLen, &encryptStart,
+                end, &c)) < 0) {
+            return rc;
+        }
+
+        // Write out status type
+        *c = CERTIFICATE_STATUS_OCSP; c++;
+
+        // Write out DER length and DER
+        DER = ssl->keys->OCSPResponseBuf;
+        if (DERLen > 0) {
+            *c = (unsigned char)((DERLen & 0xFF0000) >> 16); c++;
+            *c = (DERLen & 0xFF00) >> 8; c++;
+            *c = (DERLen & 0xFF); c++;
+            memcpy(c, DER, DERLen);
+            c += DERLen;
+        }
+
+        if ((rc = postponeEncryptRecord(ssl, SSL_RECORD_TYPE_HANDSHAKE,
+                SSL_HS_CERTIFICATE_STATUS, messageSize, padLen, encryptStart, out,
+                &c)) < 0) {
+            return rc;
+        }
+        out->end = c;
+    }
+    return MATRIXSSL_SUCCESS;
+}
 #  endif /* OCSP && SERVER_SIDE_SSL */
 
 /******************************************************************************/
